# 基金交易功能设计文档 V3：交互式交易日志

本文档详细阐述了基金交易功能的设计方案和技术规格，旨在确保逻辑严谨、用户体验流畅，并为未来的功能扩展打下坚实基础。

## 1. 核心概念：以交易记录为中心

为了实现可修改、可追溯的交易历史，我们将整个系统的核心从“持仓快照”转变为“**以交易记录为中心的账本模型**”。

-   **`TradingRecord` 是唯一事实来源**: `UserPosition` 中的 `shares` (份额), `cost` (成本), 和 `realizedProfit` (落袋收益) 将不再是用户直接修改的“原始数据”，而是通过按时间顺序计算所有**已确认的** `TradingRecord` 后得出的**派生结果**。
-   **“初始持仓”即首笔交易**: 当用户通过详情弹窗录入或修改他们的“初始持仓”时，系统会在后台将其视为一笔特殊的、位于所有交易历史最前端的“**基准买入**”记录。
-   **“顺序重算 (Replay)”机制**: 任何对历史交易记录的**修改**或**删除**操作，都会触发一个后台的“顺序重算”流程。系统会从零开始，按日期顺序重新应用每一笔**已确认的**交易记录，从而计算出最新的、绝对准确的持仓状态。这个过程对用户是无感的，但它从根本上保证了财务数据的严谨性。

---

## 2. UI/UX 进化：从“操作入口”到“状态单元格”

`FundRow` 中的日期单元格将转变为一个能**反映当日交易状态**的信息单元。

-   **默认状态 (无交易)**:
    -   显示净值、涨幅、和两个独立的链接：红色的“**买**”和蓝色的“**卖**”。
    -   背景色为默认白色，或浅灰色（如果是趋势拐点）。

-   **买入交易状态 (已确认或待处理)**:
    -   “买”/“卖”链接合并为一个“**记录**”按钮。
    -   点击“记录”按钮可打开弹窗进行**编辑/删除/取消**。
    -   单元格背景变为**浅红色**。
    -   如果该日同时是趋势拐点，背景色变为**更深一度的浅红色**。

-   **卖出交易状态 (已确认或待处理)**:
    -   链接合并为“**记录**”按钮。
    -   点击“记录”按钮可打开弹窗进行**编辑/删除/取消**。
    -   单元格背景变为**浅蓝色**。
    -   如果该日是趋势拐点，背景色变为**更深一度的浅蓝色**。

-   **“每日一笔”规则**: 此UI设计天然地执行了“每日只允许一笔交易”的规则。一旦某日有了交易（无论是已确认还是待处理），“买/卖”入口即消失。

---

## 3. 数据结构设计 (Data Structure Design)

-   **统一交易模型**: 不再区分 `TradingRecord` 和 `TradingTask`。所有交易都使用一个统一的 `TradingRecord` 接口，并存储在 `userPosition.tradingRecords` 数组中。
-   **状态识别**: 通过记录的结构来判断其状态。
    -   **待处理 (Pending)**: 记录中不包含 `nav`, `sharesChange`, `amount` 等字段，但包含 `value` 字段（代表买入金额或卖出份额）。
    -   **已确认 (Confirmed)**: 记录中包含 `nav`, `sharesChange`, `amount` 等完整的成交结果字段。
-   **唯一标识**: 在“一个基金一天一笔交易”的规则下，**“基金代码 + 日期”** 的组合将作为 `TradingRecord` 的唯一标识，无需引入额外的 `id` 字段。

### `types.ts` (统一后的结构)

```typescript
export interface TradingRecord {
  date: string;
  type: 'buy' | 'sell';

  // 用于待处理交易
  value?: number; // 买入时为金额, 卖出时为份额

  // 用于已确认交易
  nav?: number;
  sharesChange?: number;
  amount?: number;
  realizedProfitChange?: number;
}
```

---

## 4. 核心业务逻辑 (Core Business Logic)

### A. 处理待处理交易 (`processPendingTasks`)

1.  **触发**: 应用加载完成或数据刷新后。
2.  **遍历**: 遍历所有基金的所有 `tradingRecords`。
3.  **识别**: 找出所有 `nav` 字段为 `undefined` 的记录。
4.  **确认**: 检查该记录的 `date` 是否已有确认的净值。
5.  **转换**: 如果净值已确认，则根据记录的 `value` 和当日净值计算出 `sharesChange`, `amount` 等，然后用这个**已确认**的新记录对象替换掉原有的**待处理**记录。
6.  **更新状态**: 使用 `setFunds` 更新整个应用的状态。

### B. 修改/删除 `TradingRecord` (无论状态)

1.  **触发**: 用户在“记录”弹窗中点击“更新交易”或“删除交易”。
2.  **定位与更新**:
    -   根据 `fund.code` 和 `record.date` 定位到 `userPosition.tradingRecords` 数组。
    -   **更新/替换/删除** 数组中对应的记录。
3.  **自动重算**: 由于 `processedFunds` 的 `useMemo` 依赖于 `funds` 状态，上述操作会自动触发持仓的“顺序重算 (Replay)”，确保界面上显示的持仓数据永远是准确的。

### C. 图表标记 (`FundChart.tsx`)

-   **接收数据**: `FundChart` 组件将接收 `tradingRecords` 数组作为 prop。
-   **渲染标记**:
    -   在图表内部，遍历 `tradingRecords`，**只处理已确认的** (`nav` 存在) 记录。
    -   在对应的日期 (`x` 轴) 和成交净值 (`y` 轴) 位置上，使用 Recharts 的 `<ReferenceDot>` 组件渲染一个点。
    -   根据 `record.type` 决定点的颜色（红色代表买，蓝色代表卖）。
-   **交互提示**: 为这些点定制 `Tooltip`，当鼠标悬停时，显示详细的交易信息（如“买入 500.00 元，成交净值 1.2345”）。

---

## 5. 组件职责变更

-   **`FundRow.tsx`**:
    -   渲染时检查 `fund.userPosition.tradingRecords` 中是否存在对应日期的记录，并根据其**结构** (是否有`nav`字段) 判断是待处理还是已确认，以决定UI形态。
    -   点击按钮时，向 `App.tsx` 传递是“创建新交易”还是“编辑旧交易”的意图，并附上 `TradingRecord` (如果是编辑)。

-   **`BuyModal.tsx` & `SellModal.tsx`**:
    -   能够接收一个可选的 `editingRecord` prop，并进入“编辑模式”。
    -   通过检查 `editingRecord.nav` 是否存在来判断是在编辑一个**已确认**的交易还是一个**待处理**的交易，并相应地预填充表单。
    -   提交按钮变为“**更新记录**”，并新增“**删除记录**”按钮。
    -   `onSubmit` 和 `onDelete` 回调需要能处理记录的更新和删除逻辑。

-   **`FundDetailModal.tsx`**:
    -   用户在此处编辑的“份额”、“成本”和“累计收益”，实际上是在修改那条“**基准买入**”的 `TradingRecord`。保存时同样会触发完整的“顺序重算”。

---

## 总结

此方案将应用的核心功能从“当前状态快照”转变为一个“完整的、可追溯的交易账本”。通过**统一数据模型**和**结构化状态判断**，简化了数据管理和同步逻辑。实现的关键在于**引入“顺序重算”机制**来确保数据的准确性，并在UI上提供清晰的状态反馈和便捷的编辑入口，同时在图表上提供直观的交易点标记，极大地提升了应用的专业性和可用性。